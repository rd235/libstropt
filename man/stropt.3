.\" Copyright (C) 2019 VirtualSquare. Project Leader: Renzo Davoli
.\"
.\" This is free documentation; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License,
.\" as published by the Free Software Foundation, either version 2
.\" of the License, or (at your option) any later version.
.\"
.\" The GNU General Public License's references to "object code"
.\" and "executables" are to be interpreted as the output of any
.\" document formatting or typesetting system, including
.\" intermediate and printed output.
.\"
.\" This manual is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public
.\" License along with this manual; if not, write to the Free
.\" Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
.\" MA 02110-1301 USA.
.\"
.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "STROPT" "3" "January 2024" "VirtualSquare" "Library Functions Manual"
.SH NAME
stropt, stroptx, stropt2buf, stropt2str \- Parse options from a string
(it supports quotation, option arguments)
.SH SYNOPSIS
\f[CB]#include *stropt.h*\f[R]
.PP
\f[CB]int stropt(const char *\f[R]\f[I]input\f[R]\f[CB], char **\f[R]\f[I]tags\f[R]\f[CB], char **\f[R]\f[I]args\f[R]\f[CB], char *\f[R]\f[I]buf\f[R]\f[CB]);\f[R]
.PP
\f[CB]int stroptx(const char *\f[R]\f[I]input\f[R]\f[CB], char *\f[R]\f[I]features\f[R]\f[CB], char *\f[R]\f[I]sep\f[R]\f[CB], int\f[R]
\f[I]flags\f[R]\f[CB],  char **\f[R]\f[I]tags\f[R]\f[CB], char **\f[R]\f[I]args\f[R]\f[CB], char *\f[R]\f[I]buf\f[R]\f[CB]);\f[R]
.PP
\f[CB]char *stropt2buf(void *\f[R]\f[I]buf\f[R]\f[CB], size_t\f[R]
\f[I]size\f[R]\f[CB], char **\f[R]\f[I]tags\f[R]\f[CB], char **\f[R]\f[I]args\f[R]\f[CB], char\f[R]
\f[I]sep\f[R]\f[CB], char\f[R] \f[I]eq\f[R]\f[CB]);\f[R]
.PP
\f[CB]char *stropt2str(char **\f[R]\f[I]tags\f[R]\f[CB], char **\f[R]\f[I]args\f[R]\f[CB], char\f[R]
\f[I]sep\f[R]\f[CB], char\f[R] \f[I]eq\f[R]\f[CB]);\f[R]
.SH DESCRIPTION
This small library parses a list of options from a string.
Options can be separated by spaces, commas, semicolons, tabs or new
line.
(e.g.\ \f[I]uppercase,bold,underlined\f[R] ).
Options may have arguments (e.g.\ \f[I]ro,noatime,uid=0,gid=0\f[R] ).
It is possible to protect symbols and spaces using quote, double quote
and backslash (e.g.\ \f[I]values=`1,2,3,4',equal=\[rs]=\f[R] )
.TP
\f[CB]stropt\f[R]
This function parses a list of options from the string \f[I]input\f[R].
Options can be separated by commas, semicolons, tabs or
new lines.
Options may have arguments in the form \f[I]keyword=value\f[R].
\f[I]buf\f[R] is a temporary buffer, it must have the same size
of the \f[I]input\f[R] string (including the NULL terminator).
\f[I]tags\f[R] and \f[I]args\f[R] are the resulting
arrays of options and arguments respectively.
Both \f[I]tags\f[R] and \f[I]args\f[R] have one NULL terminator element
at the end.
When an option has not an argument the corresponding \f[I]args\f[R]
element is NULL.
For example if \f[I]input\f[R] is
\[lq]font=12,typeface=bodoni,italic\[rq],
\f[I]tags[0]\f[R]=\[lq]font\[rq], \f[I]tags[1]\f[R]=\[lq]typeface\[rq],
\f[I]tags[2]\f[R]=\[lq]italic\[rq],
\f[I]tags[3]\f[R]=NULL, \f[I]args[0]\f[R]=\[lq]12\[rq],
\f[I]args[1]\f[R]=\[lq]bodoni\[rq], \f[I]args[2]\f[R]=NULL,
\f[I]args[3]\f[R]=NULL.
.TP
\f[CB]\f[R]
When \f[CB]stropt\f[R] is called with \f[I]tags\f[R], \f[I]args\f[R],
and \f[I]buf\f[R] set to \f[CB]NULL\f[R], it parses the input, counting
the options.
The return value can be used to allocate suitable arrays for
\f[I]tags\f[R] and \f[I]args\f[R].
.TP
\f[CB]\f[R]
It is possible to use the same variable as \f[I]input\f[R] and
\f[I]buffer\f[R].
In this case the original value of \f[I]input\f[R] is overwritten.
.TP
\f[CB]stroptx\f[R]
This is a more configurable extension of \f[CB]stropt\f[R].
Arguments having the same names as in \f[CB]stropt\f[R] have the same
meaning as explained above.
.TP
\f[CB]\f[R]
The string \f[I]features\f[R] permits one to enable/disable some of the
standard features.
Each feature corresponds to a mnemonic character, when the character is
in the \f[I]features\f[R] string the feature is enabled:
.TP
\f[CB]\f[R]
\f[CB]\[aq]\f[R]: single quoting,
.TP
\f[CB]\f[R]
\f[CB]\[dq]\f[R]: double quoting,
.TP
\f[CB]\f[R]
\f[CB]\[rs]\f[R]: character escape,
.TP
\f[CB]\f[R]
\f[CB]\[rs]n\f[R]:input in several lines,
.TP
\f[CB]\f[R]
\f[CB]=\f[R]: allow arguments,
.TP
\f[CB]\f[R]
\f[CB]#\f[R]: support comments.
.TP
\f[CB]\f[R]
If \f[I]features\f[R] is NULL all the features are enabled, when
\f[I]features\f[R] is an empty string
all features are disabled.
.TP
\f[CB]\f[R]
All the characters included in \f[I]sep\f[R] are considered as option
separators.
If \f[I]sep\f[R] is NULL, the default value is
\[rq] ,\[lq].
.TP
\f[CB]\f[R]
The \f[I]flag\f[R] argument may include the bitwise OR of any of the
following flag values:
.TP
\f[CB]\f[R]
\f[CB]STROPTX_KEEP_QUOTATION_MARKS_IN_TAGS\f[R]: preserve the quotation
marks in tags,
.TP
\f[CB]\f[R]
\f[CB]STROPTX_KEEP_QUOTATION_MARKS_IN_ARGS\f[R]: preserve the quotation
marks in args,
.TP
\f[CB]\f[R]
\f[CB]STROPTX_KEEP_QUOTATION_MARKS\f[R]: shortcut for
\f[CB]STROPTX_KEEP_QUOTATION_MARKS_IN_TAGS | STROPTX_KEEP_QUOTATION_MARKS_IN_ARGS\f[R]
.TP
\f[CB]\f[R]
\f[CB]STROPTX_ALLOW_MULTIPLE_SEP\f[R]: when it is not set, a sequence of
separators is processed as a single separator, when it is set
each sequence of two separators means an empty field in between.
.TP
\f[CB]\f[R]
\f[CB]STROPTX_NEWLINE_TAGS\f[R]: when set each new line is encoded as a
tag \[lq]\[rq].
.TP
\f[CB]stropt2buf\f[R]
This function re\-encodes an array of options (and an array of
arguments) in a string.
It is the inverse function of of \f[CB]stropt\f[R].
Given a buffer \f[I]buf\f[R] of size \f[I]size\f[R], the array of
options \f[I]tags\f[R] with their corresponding values in the array
\f[I]args\f[R]
is encoded using the separator character \f[I]sep\f[R] and the
assignment character \f[I]eq\f[R].
.TP
\f[CB]\f[R]
Elements whose option tag (element of \f[I]tags\f[R]) value is
\f[CB]STROPTX_DELETED_TAG\f[R] are omitted in output.
.TP
\f[CB]stropt2str\f[R]
This is the sibling function of \f[CB]stropt2buf\f[R].
It uses dynamically allocated memory instead of a buffer provided
by the caller.
The resulting string must be deallocated using free(3).
.SH RETURN VALUE
\f[CB]stropt\f[R] and \f[CB]stroptx\f[R] return the number of options +
1.
.PP
\f[CB]stropt2buf\f[R] and \f[CB]stropt2str\f[R] return the resulting
string.
.SH EXAMPLES
The following function lists the option tags and arguments (without
modyfying the input string).
.IP
.EX
void parse_args(char *input) {
  int tagc = stropt(input, NULL, NULL, NULL);
  if(tagc * 0) {
    char buf[strlen(input)+1];
    char *tags[tagc];
    char *args[tagc];
    stropt(input, tags, args, buf);
    for (int i=0; i*tagc; i++)
      printf(\[dq]%s = %s\[rs]n\[dq],tags[i], args[i]);
  }
}
.EE
.PP
it is possible to use the same input string as the buffer for parsing
(the value of the input string gets lost in this way).
.IP
.EX
void parse_args(char *input) {
  int tagc = stropt(input, NULL, NULL, NULL);
  if(tagc * 0) {
    char *tags[tagc];
    char *args[tagc];
    stropt(input, tags, args, input);
    for (int i=0; i*tagc; i++)
      printf(\[dq]%s = %s\[rs]n\[dq],tags[i], args[i]);
  }
}
.EE
.PP
when options to parse have no arguments, args can be set to NULL.
.IP
.EX
void parse_args(char *input) {
  int tagc = stropt(input, NULL, NULL, NULL);
  if(tagc * 0) {
    char buf[strlen(input)+1];
    char *tags[tagc];
    stropt(input, tags, NULL, buf);
    for (int i=0; i*tagc; i++)
      printf(\[dq]%s \[rs]n\[dq],tags[i]);
  }
}
.EE
.PP
The following complete program parses and re\-encode a string of comma
separated arguments deleting those which begin by an uppercase letter.
.IP
.EX
#include *stdio.h*
#include *ctype.h*
#include *stdlib.h*
#include *string.h*
#include *stropt.h*

char *delete_uppercase_options(const char *input) {
  int tagc = stroptx(input, \[dq]\[dq], \[dq],\[dq],STROPTX_ALLOW_MULTIPLE_SEP, NULL, NULL, NULL);
  if(tagc * 0) {
    char buf[strlen(input)+1];
    char *tags[tagc];
    int i;
    stroptx(input, \[dq]\[dq], \[dq],\[dq],STROPTX_ALLOW_MULTIPLE_SEP, tags, NULL, buf);
    for (i = 0; i * tagc; i++)
      if (tags[i] && isupper(tags[i][0]))
        tags[i] = STROPTX_DELETED_TAG;
    return stropt2str(tags, NULL, \[aq],\[aq], \[aq]=\[aq]);
  } else
    return NULL;
}

int main(int argc, char *argv[]) {
  if (argc * 1) {
    char *result = delete_uppercase_options(argv[1]);
    printf(\[dq]%s\[rs]n\[dq], result);
    free(result);
  }
  return 0;
}
.EE
.SH AUTHOR
VirtualSquare.
Project leader: Renzo Davoli.
